#pragma kernel Diverge

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> Divergence;
StructuredBuffer<float3> Velocity;
StructuredBuffer<int> Solid;
int N;

int index(int x, int y, int z) {
    return x + (y * N) + (z * N * N);
}

[numthreads(8, 8, 8)]
void Diverge(uint3 id : SV_DispatchThreadID) {
    float rightX = 0.0f;
    float leftX = 0.0f;
    float topY = 0.0f;
    float bottomY = 0.0f;
    float frontZ = 0.0f;
    float backZ = 0.0f;

    if (id.x + 1 < N) {
        if (Solid[index(id.x + 1, id.y, id.z)] == 1) {
            rightX = 0.0f;
        } else {
            rightX = Velocity[index(id.x + 1, id.y, id.z)].x;
        }
    } else {
        if (Solid[index(id.x, id.y, id.z)] == 1) {
            rightX = 0.0f;
        } else {
            rightX = Velocity[index(id.x, id.y, id.z)].x;
        }
    }

    if (id.x > 0) {
        if (Solid[index(id.x - 1, id.y, id.z)] == 1) {
            leftX = 0.0f;
        } else {
            leftX = Velocity[index(id.x - 1, id.y, id.z)].x;
        }
    } else {
        if (Solid[index(id.x, id.y, id.z)] == 1) {
            leftX = 0.0f;
        } else {
            leftX = Velocity[index(id.x, id.y, id.z)].x;
        }
    }

    if (id.y + 1 < N) {
        if (Solid[index(id.x, id.y + 1, id.z)] == 1) {
            topY = 0.0f;
        } else {
            topY = Velocity[index(id.x, id.y + 1, id.z)].y;
        }
    } else {
        if (Solid[index(id.x, id.y, id.z)] == 1) {
            topY = 0.0f;
        } else {
            topY = Velocity[index(id.x, id.y, id.z)].y;
        }
    }

    if (id.y > 0) {
        if (Solid[index(id.x, id.y - 1, id.z)] == 1) {
            bottomY = 0.0f;
        } else {
            bottomY = Velocity[index(id.x, id.y - 1, id.z)].y;
        }
    } else {
        if (Solid[index(id.x, id.y, id.z)] == 1) {
            bottomY = 0.0f;
        } else {
            bottomY = Velocity[index(id.x, id.y, id.z)].y;
        }
    }

    if (id.z + 1 < N) {
        if (Solid[index(id.x, id.y, id.z + 1)] == 1) {
            frontZ = 0.0f;
        } else {
            frontZ = Velocity[index(id.x, id.y, id.z + 1)].z;
        }
    } else {
        if (Solid[index(id.x, id.y, id.z)] == 1) {
            frontZ = 0.0f;
        } else {
            frontZ = Velocity[index(id.x, id.y, id.z)].z;
        }
    }

    if (id.z > 0) {
        if (Solid[index(id.x, id.y, id.z - 1)] == 1) {
            backZ = 0.0f;
        } else {
            backZ = Velocity[index(id.x, id.y, id.z - 1)].z;
        }
    } else {
        if (Solid[index(id.x, id.y, id.z)] == 1) {
            backZ = 0.0f;
        } else {
            backZ = Velocity[index(id.x, id.y, id.z)].z;
        }
    }

    Divergence[index(id.x, id.y, id.z)] = -0.5f * (rightX - leftX + topY - bottomY + frontZ - backZ) * N;
}
