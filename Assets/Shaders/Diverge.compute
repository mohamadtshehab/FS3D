// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Diverge

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> Divergence;
StructuredBuffer<float3> Velocity;
int N;

int index(int x, int y, int z){
    return (x) + (y) *(N) + (z) * (N) * (N);
    }
[numthreads(8,8,8)]
void Diverge(uint3 id : SV_DispatchThreadID)
{
    float rightX = 0.0f;
    float leftX = 0.0f;
    float topY = 0.0f;
    float bottomY = 0.0f;
    float backZ = 0.0f;
    float frontZ = 0.0f;

    if (id.x + 1 < N)
        rightX = Velocity[index(id.x + 1, id.y, id.z)].x;
    else
        rightX = Velocity[index(id.x, id.y, id.z)].x;

    if (id.x > 0)
        leftX = Velocity[index(id.x - 1, id.y, id.z)].x;
    else
        leftX = Velocity[index(id.x, id.y, id.z)].x;

    if (id.y + 1 < N)
        topY = Velocity[index(id.x, id.y + 1, id.z)].y;
    else
        topY = Velocity[index(id.x, id.y, id.z)].y;

    if (id.y > 0)
        bottomY = Velocity[index(id.x, id.y - 1, id.z)].y;
    else
        bottomY = Velocity[index(id.x, id.y, id.z)].y;

    if (id.z + 1 < N)
        backZ = Velocity[index(id.x, id.y, id.z + 1)].z;
    else
        backZ = Velocity[index(id.x, id.y, id.z)].z;

    if (id.z > 0)
        frontZ = Velocity[index(id.x, id.y, id.z-1)].z;
    else
        frontZ = Velocity[index(id.x, id.y, id.z)].z;

    Divergence[index(id.x, id.y, id.z)] = -0.5f * (rightX - leftX + topY - bottomY + backZ - frontZ) / N;
}
