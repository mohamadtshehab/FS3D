
#pragma kernel Advect

RWStructuredBuffer<float3> Quantity;
StructuredBuffer<float3> ToAdvectQuantity;
StructuredBuffer<float3> ToAdvectOverVelocity;
float TimeStep;
int N;

int index(int x, int y){
    return (x) + (y) *(N);
    }

[numthreads(8,8,1)]
void Advect (uint3 id : SV_DispatchThreadID)
{
    float dtx = TimeStep;
    float dty = TimeStep;

    float3 dt = float3(dtx, dty, 0);
    float nFloat = N;
    float3 coordinates = float3(id.x, id.y, 0);
    float3 XY = coordinates -  dt * ToAdvectOverVelocity[index(id.x, id.y)];

    if (XY.x < 0.5f) XY.x = 0.5f;
    if (XY.x > nFloat + 0.5f) XY.x = nFloat + 0.5f;
    int i0 = floor(XY.x);
    int i1 = i0 + 1;

    if (XY.y < 0.5f) XY.y = 0.5f;
    if (XY.y > nFloat + 0.5f) XY.y = nFloat + 0.5f;
    int j0 = floor(XY.y);
    int j1 = j0 + 1;

    float s1 = XY.x - i0;
    float s0 = 1.0f - s1;
    float t1 = XY.y - j0;
    float t0 = 1.0f - t1;


    float3 QuantityI0J0 = ToAdvectQuantity[index(i0, j0)];
    float3 QuantityI0J1 = ToAdvectQuantity[index(i0, j1)];
    float3 QuantityI1J0 = ToAdvectQuantity[index(i1, j0)];
    float3 QuantityI1J1 = ToAdvectQuantity[index(i1, j1)];
         
    Quantity[index(id.x, id.y)] = 
        s0 * (t0 * QuantityI0J0 + t1 * QuantityI0J1) +
        s1 * (t0 * QuantityI1J0 + t1 * QuantityI1J1);
    }


